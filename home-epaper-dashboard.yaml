# Nelsons E-Paper Dashboard
# For Home Assistant and ESPHome
packages:
  # Config
  device_base: !include modules/device_base.yaml
  wifi: !include modules/wifi.yaml
  fonts: !include modules/fonts.yaml
  variables: !include modules/variables.yaml

  # Sensors
  outdoor_temperature: !include sensors/outdoor_temperature.yaml
  indoor_temperature: !include sensors/indoor_temperature.yaml

script:
  - id: update_screen
    then:
      - logger.log: "Executing update_screen script."
      - component.update: eink_display

# Use Home Assistant's clock
time:
  - platform: homeassistant
    id: homeassistant_time

# Display Function
display:
  - platform: waveshare_epaper
    id: eink_display
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin: GPIO25
    reset_pin: GPIO26
    reset_duration: 2ms
    model: 7.50in-bV3
    update_interval: never
    rotation: 90°
    lambda: |-
      it.fill(color_black);
      it.printf(10, 30, id(font_bold_large), color_white, TextAlign::TOP_LEFT, "WEATHER");
      it.printf(10, 80, id(font_bold_medium), color_white, TextAlign::TOP_LEFT, "TEMPS");

      if (id(initial_data_received)) {
        it.printf(10, 120, id(font_regular_medium), color_white, TextAlign::TOP_LEFT, "%2.1f°C", id(indoor_temperature).state);

       // Map the weather conditions to their corresponding Material Design Icons
        //  https://pictogrammers.com/library/mdi/
        std::map<std::string, std::string> weather_icon_map = {
          {"mdi:weather-sunny", "\U000F0599"}, // mdi-weather-sunny
          {"mdi:weather-night", "\U000F0594"}, // mdi-weather-night
          {"mdi:weather-mostly_sunny", "\U000F0594"}, // mdi-weather-partly-cloudy
          {"mdi:weather-partly_cloudy", "\U000F0594"}, // mdi-weather-partly-cloudy
          {"mdi:weather-cloudy", "\U000F0590"}, // mdi-weather-cloudy
          {"mdi:weather-overcast", "\U000F0590"}, // mdi-weather-cloudy
          {"mdi:weather-fog", "\U000F0591"}, // mdi-weather-fog
          {"mdi:weather-showers", "\U000F0597"}, // mdi-weather-rainy
          {"mdi:weather-rainy", "\U000F0597"}, // mdi-weather-pouring
          {"mdi:weather-dust", "\U000F0592"}, // mdi-weather-windy
          {"mdi:weather-frost", "\U000F02DC"}, // mdi-snowflake
          {"mdi:weather-snow", "\U000F02DC"}, // mdi-snowflake
          {"mdi:weather-storm", "\U000F059D"}, // mdi-weather-lightning
          {"mdi:weather-light_showers", "\U000F0597"}, // mdi-weather-rainy
          {"mdi:weather-heavy_showers", "\U000F0598"}, // mdi-weather-pouring
          {"mdi:weather-tropical_cyclone", "\U000F0898"}, // mdi-weather-hurricane
        };

        // Get the state of the sun
        std::string sun_state_str = id(sun_state)->state;

        // Log the value of current_weather_icon
        ESP_LOGD("main", "Current weather icon: %s", id(current_weather_icon).state.c_str());

        // If the sun is below the horizon, show the night icon
        std::string weather_icon;
        if (sun_state_str == "below_horizon") {
          if (id(current_weather_icon).state == "mdi:weather-sunny"){
            weather_icon = "mdi:weather-night";
          }
        } else {
          // Get the icon from the weather.temperature entity
          weather_icon = id(current_weather_icon).state;
        }

        ESP_LOGD("main", "Weather icon: %s", weather_icon.c_str());

        // Display the icon
        it.printf(400, 120, id(font_mdi_medium), color_white, TextAlign::TOP_RIGHT, "%s", weather_icon_map[weather_icon.c_str()].c_str());

        // Get the current date and time
        auto time = id(homeassistant_time).now();

        // Display the forecast and icon for each day
        it.printf(10, 200, id(font_regular_small), color_white, TextAlign::TOP_LEFT, "TODAY: Max %2.1f°C, Min %2.1f°C", id(forecast_temp_max_0).state, id(forecast_temp_min_0).state);
        it.printf(10, 220, id(font_regular_small), color_white, TextAlign::TOP_LEFT, "%02d %s: Max %2.1f°C, Min %2.1f°C", time.day_of_month + 1, time.strftime("%b").c_str(), id(forecast_temp_max_1).state, id(forecast_temp_min_1).state);
        it.printf(10, 240, id(font_regular_small), color_white, TextAlign::TOP_LEFT, "%02d %s: Max %2.1f°C, Min %2.1f°C", time.day_of_month + 2, time.strftime("%b").c_str(), id(forecast_temp_max_2).state, id(forecast_temp_min_2).state);
        it.printf(10, 260, id(font_regular_small), color_white, TextAlign::TOP_LEFT, "%02d %s: Max %2.1f°C, Min %2.1f°C", time.day_of_month + 3, time.strftime("%b").c_str(), id(forecast_temp_max_3).state, id(forecast_temp_min_3).state);

        it.printf(400, 200, id(font_mdi_medium), color_white, TextAlign::TOP_RIGHT, "%s", weather_icon_map[id(sensor_forecast_mdi_icon_0).state.c_str()].c_str());
        it.printf(400, 220, id(font_mdi_medium), color_white, TextAlign::TOP_RIGHT, "%s", weather_icon_map[id(sensor_forecast_mdi_icon_1).state.c_str()].c_str());
        it.printf(400, 240, id(font_mdi_medium), color_white, TextAlign::TOP_RIGHT, "%s", weather_icon_map[id(sensor_forecast_mdi_icon_2).state.c_str()].c_str());
        it.printf(400, 260, id(font_mdi_medium), color_white, TextAlign::TOP_RIGHT, "%s", weather_icon_map[id(sensor_forecast_mdi_icon_3).state.c_str()].c_str());
        
        ESP_LOGD("display", "Display updated with temperature data.");
      } else {
        it.printf(200, 400, id(font_regular_medium), color_white, TextAlign::CENTER, "Waiting for data...");
        ESP_LOGW("display", "Display update called without data.");
      }